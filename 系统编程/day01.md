#Linux系统编程 day01
##进程同步与互斥

* 有些资源需要互斥使用，因此各个进程间竞争使用这些资源，这些进程为互斥
这些资源被称为临界资源或互斥资源
在程序中设计到互斥资源的程序段落叫做临界区
* 多个进程相互配合完成一项任务叫做进程同步

##进程间通信形势

**管道 **有名：任意两个进程 无名：亲缘关系的进程之间通信
**System V进程通信**
**POSIX进程通信标准，规定了进程间通信的机制**

##系统进程通信的分类

1. 文件
2. 文件锁	                                  用于互斥(读写锁)
3. 管道(pipe)和有名管道(FIFO)	进程间传输诗句
4. 信号(signal)	向别的进程发送通知事件
5. 消息队列		                                    system v具有	POSIX具有
6. 共享内存		                                    system v具有	POSIX具有
7. 信号量		                                    	system v具有	POSIX具有
8. 互斥量			                                    POSIX具有
9. 条件变量		                                    POSIX具有
10. 读写锁			                                    POSIX具有
11. 套接字(socket)

**进程间共享信息的三种方式**

1. 共享文件系统
2. 共享信息			
3. 共享内存		效率高不涉及对内核的访问

##`IPC`对象的持续性

* 随着最后一个进程结 束一直存在  (pipe 和 FIFO)
* 随着内核持续	(System V消息队列，共享内存和信号量) 内核自举(机器重启或重新加载内核)和显式删除
* 伴随文件系统持续 (POSIX消息队列，共享内存和信号量)	保存在文件系统中，直到显式删除

总结：POSIX至少是随内核持续的POSIX没有规定实现方式，只是规定了接口

##死锁

多个进程相互等待对方占有的资源，而在得到对方资源的同时又不释放自己的资源，这样会造成循环等待的现象
如果所有进程都在等待不可能发生的事，这进程就死锁了

**死锁的必要条件：**

1. 互斥，对资源的访问只能是一个进程
2. 请求和保持条件，仅为请求资源阻塞，就不会释放自己的资源
3. 不可剥夺：资源未使用完时不能被其他进程剥夺
4. 封闭环形链

解决方法：破坏其中一个条件，但是一般不破坏互斥条件

##信号量与P,V原语

* S>0 是表示当前可以资源数
* S=0 表示无可用，无等待进程
* S<0 |S|表示等待进程个数
```
sturct semaphore{
	int value;			//计数值
	pointer_PCB queue;	//等待队列当前由那些进程处于等待状态，这是一个指向进程控制块的指针
};
```

P原语：
```
P(s){
	s.value = s.value--;
	if(s.value <=0){
		该进程状态置为等待，将进程的PCB插入等待队列s.queue末尾
	}
}
```

V原语：
```
V(s){
	s.value = s.value++;
	if(s.value <=0){
		唤醒等待队列s.queue中的第一个进程，改变其状态为就绪状态，并将其插入就绪队列
	}
}
```
*P,V操作都是原子性的不能被打断*
