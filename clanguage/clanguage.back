#C语言
##字节对齐规则
**字节对齐详细讲解 **
1. 我们的结构体变量本身就是在4字节对齐的位置,编译器帮我们做的事。
2. 第一个成员，就从结构体开始的地址处，存放。这个元素，具体占多少字节，由紧挨着下个元素决定。 
3.  整个结构体还要是默认字节对齐的最小整数倍。 
结构体默认的字节对齐：成员变量最大的那个类型所占字节 
64位机下在设置对齐时会将结构体最大的元素与8字节比较，取其小

例如在如下例子中 
最大的成员是a(4字节)<8字节 
所以以4字节对齐
```
typedef struct data
{
        int a;              // 4
        char b;             // 1 + 1（填充）
        short c;          // 2    最后整个结构体自身还要对齐
//      double d;
}D;//8字节
```

下例中最大成员是b(8字节) 
根据上面的说法 以8字节对齐

```
struct data1
{
        int a;//4+4(填充)
        double b;//8
}d;//16字节
```
**字节对齐命令 **
``#pragma pack(n) （1、2、4、8、…..） ``
…… 
``#pragma pack() ``
这两个配合使用，表示一个区间，只有这个区间内的结构体享受这个待遇。 
设置 对齐。 
设置为1，就是不对齐 
1、充分利用内存空间，牺牲了速度，降低了访问效率。 
2、提高效率、性能，牺牲了内存空间。 
总结：你指定的对齐方式和结构体自身默认对齐方式，俩者取最小的。 
用法举例： 
下例的意思是以2字节对齐 
所以是s1结果是14 
s1是2
```
#pragma pack(2)
struct data                 
{
        int a;//2*2字节
        char b;//1+1(填充)
        double c;//2*4字节
}s;

struct data1
{
        char ch;
}s1;
#pragma pack()
```
##位字段 
**位字段：**

* 专用于结构体，结构体成员的类型必须是：int || unsigned int 
* 有时侯，结构体成员表示的数据很小，就用几个位来表示。 

下例1 
a占32位中的1bit 
b占2bit 
c占2bit 
后面全部填充

```
struct data  //4
{
        unsigned a : 1;  // 1就是一个bit，范围：0～1
        unsigned b : 2;  // 2就是er个bit，范围：0～3
        unsigned c : 2; // 28位 
}s, *p = &s;
```

例子2

```
struct data2    //12
{
        unsigned a : 1;     // 1就是一个bit，范围：0～1
        int : 0;                    // 0字段，不可访问，只是占位  整个字剩下的位，全部写0
        unsigned b : 30;    // 2就是er个bit，范围：0～3
        int : 0;
        unsigned c : 2;   // 28位 
}s2;
```
例子3

```
struct data3   //8
{
        int a : 2;//先占2个bit 后面的30个全部填充
        int b : 32;
}s3;
```

##off_set_of和containe_of
**linux内核里的两个宏：在驱动应用中很广泛。 **
`#define off_set_of(type, member) ((long)&(((type *)0)->member))`

`#define container_of(ptr, type, member) ({typeof(((type )0)>member) *_mptr = ptr;(type )((char )_mptr-off_set_of(type, member));})`

**分析：**
1. （type *）0指向结构体零地址 \ 
2. (（type *）0)->member得到了结构体某个成元变量名 \ 
3. 给这成员变量名，取地址(相对于零地址)，此时&(((type *)0)->member)表示是指针类型 \ 
4. 强制类型转换成long。

```
struct da
{
        int a;
        short b;
        int c;
        double e;
};                      // 16
struct data
{
        char a;      //2
        short b;     //2
        int c;      // 4
//      float d;    // 8
//  double e;       // 8
        struct da s;    // 16
        char ch;
}s = {1, 3, 10, 3.14, 1.41};
```

```
int main(void)
{
    int off = off_set_of(struct data, c);
    printf("off = %d.\n", off);     // off 4
    ff = off_set_of(struct data, d);
    printf("off = %d.\n", off);         // off 8
    off = off_set_of(struct data, e);
    printf("off = %d.\n", off);         // off 16
}
```
```
struct data *p = container_of(p_e, struct data, e);
//得到成员e的结构体首地址
```

##柔性数组 
**柔性数组：**
是在结构体里，有一个数组，必须是结构体最后的一个元素，而且由特定形式[]或[0]; 
整体的结构体至少有两个成员变量。

```
typedef struct
{
        int len;
        int arr[];
}S;
```

```
//生成柔性数组
void create_soft_arr(int len)
{
        S *p = (S *)malloc(sizeof(S) + sizeof(int)*len);
        //让a成员控制我数组个数
        p->len = len;
        int i = 0;
        for (i=0; i<len; i++)
        {
                if (i <= 1)
                        p->arr[i] = 1;
                else if (i >= 2)
                        p->arr[i] = p->arr[i-1] + p->arr[i-2];
        }
        //看一下 用func
        free(p);
}
```

##关于内存的理解
**虚拟内存分段**
栈段、堆段、代码段(.text) 、roread段、文件映射区、内核区、数据段、.bss段 

**存储类 **

* 储存变量的地方


* 栈
   * 定义栈上变量关键字auto 
通常情况下，普通变量(int char之类的)储存在栈上 
函数传递的参数，在调用完后跟栈消失，也就是函数的局部变量


*  堆
   * malloc申请的空间，一段连续的内存，在使用完后切断与它的联系(free)

   
* 代码段区域
   * 例如，char *p=”abcd”;这句话中”abcd”存储在代码段，p指向该代码段 
一般地代码段不能修改


* roread段
   * 关键字：const 
如果直接修改const修饰的变量值编译器会警告，如果要修改，则要使用指针。


* 文件映射区
   * 当你进程打开一个文件，就在内存中有了相应的一个副本，更新或者操作这个文件之后保存，就保存在了你的硬盘上


* 内核区
   * 操作系统内核所占的区域，在各个进程中独自享有整个虚拟内存空间，所以每一个进程之间相互独立，每一个进程都有一个内核区


* data段
   * static修饰的显式初始化为非0的局部变量 
显式初始化为非0的全局变量。


* .bss段
   * 与data对应，static修饰的初始化为0或者不初始化的局部变量 
初始化为0或者不初始化的全局变量



**关键字解释**

* static:修饰局部变量每次调用时，保留上一次的运行结果 
* register关键字，修饰的变量，尽可能存在寄存器里。 
* volatile：定义的变量会在程序外被改变,每次都必须从内存中读取，而不能重复使用放在cache或寄存器中的备份，不能做任何优化 
* restrict：只能用于修饰指针.表明指针是访问一个数据对象的惟一且初始的方式 
* restrict有两个读者。一个是编译器，它告诉编译器可以自由地做一些有关优化的假定。另一个读者是用户，它告诉用户仅使用满足restrict要求的参数。一般，编译器无法检查您是否遵循了这一限制，如果您蔑视它也就是在让自己冒险。

**作用域**

* 变量从出现到消失的过程 
* 栈变量，作用于花括号{}的区域内，当{}结束，或者函数使用完，就释放掉了 
* 堆变量，作用于花括号内，从你定义的那一刻直到花括号结束，伴随整个程序，直到程序结束 
* 代码段，伴随整个程序 
* roread变量，于普通变量相同作用于花括号{}伴随整个程序。 
* data段变量：作用域：定义时，之后直到程序结束都可以用（1、全局，2、局部），伴随整个程序。

**链接属性**

* `extern `用于声明 
我们很多很多文件（.c）就组成一个工程。 
c语言编译链接过程：所有的.c文件，编译成了.o的目标文件(2进制)，彼此是孤立的，接着就是链接器，链接起来。所有的.o的目标文件都对应一个相应的符号。所有的符号进行链接。 
在os下：写好的可执行文件，是别人给你写好了一段对C语言引导作用代码，加载到相应的内存。 
* `data`段和`.bss`：在你的C语言(宏替换之前)运行之前，(引导干的)你的`.data`段已经被赋值，`.bss`段被清0. 
* 全局变量：链接属性是外链接(文件级别)，而加了`static`修饰的全局变量就变成了本文件链接属性(内链接) 
* 函数：默认是外链接，`static`修饰的函数变成了内链接，只在本文件起作用。


