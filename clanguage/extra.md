#C语言进阶
##内存的理解

[返回](day01.md)

1. 栈、 
定义栈上变量关键字auto 
通常情况下，普通变量(int char之类的)储存在栈上 
函数传递的参数，在调用完后跟栈消失，也就是函数的局部变量

2. 堆、 
malloc申请的空间，一段连续的内存，在使用完后切断与它的联系(free)

3. 代码段区域.txt段、 
例如，char *p=”abcd”;这句话中”abcd”存储在**字符常量区**，p指向该代码段
代码段区域一般存放可执行二进制代码
一般地代码段不能修改

4. roread段、 
关键字：const 
如果直接修改const修饰的变量值编译器会警告，如果要修改，则要使用指针。

5. 文件映射区、 
当你进程打开一个文件，就在内存中有了相应的一个副本，更新或者操作这个文件之后保存，就保存在了你的硬盘上。

6. 内核区、 
操作系统内核所占的区域，在各个进程中独自享有整个虚拟内存空间，所以每一个进程之间相互独立，每一个进程都有一个内核区

7. data段、 
static修饰的显式初始化为非0的局部变量 
显式初始化为非0的全局变量。

8. .bss段 
与data对应，static修饰的初始化为0或者不初始化的局部变量 
初始化为0或者不初始化的全局变量

**关键字解释**
 
* static:修饰局部变量每次调用时，保留上一次的运行结果 
* register关键字，修饰的变量，尽可能存在寄存器里。 
* volatile：定义的变量会在程序外被改变,每次都必须从内存中读取，而不能重复使用放在cache或寄存器中的备份，不能做任何优化 
* restrict：只能用于修饰指针.表明指针是访问一个数据对象的惟一且初始的方式 
* restrict有两个读者。一个是编译器，它告诉编译器可以自由地做一些有关优化的假定。另一个读者是用户，它告诉用户仅使用满足restrict要求的参数。一般，编译器无法检查您是否遵循了这一限制，如果您蔑视它也就是在让自己冒险。

**作用域** 
花括号{}里面的变量，只能在里定义时，到你的花括号结束有效。定义和声明有时候不会严格区分

**生命周期:**
变量从出现到消失的过程
 
* 栈变量，作用于花括号{}的区域内，当{}结束，或者函数使用完，就释放掉了 
* 堆变量，作用于花括号内，从你定义的那一刻直到花括号结束，伴随整个程序，直到程序结束 
* 代码段，伴随整个程序 
* roread变量，于普通变量相同作用于花括号{}伴随整个程序。 
*data段变量：作用域：定义时，之后直到程序结束都可以用（1、全局，2、局部），伴随整个程序。

**链接属性**
 
* extern 用于声明 
我们很多很多文件（.c）就组成一个工程。 
c语言编译链接过程：所有的.c文件，编译成了.o的目标文件(2进制)，彼此是孤立的，接着就是链接器，链接起来。所有的.o的目标文件都对应一个相应的符号。所有的符号进行链接。 
在os下：写好的可执行文件，是别人给你写好了一段对C语言引导作用代码，加载到相应的内存。 
* data段和.bss：在你的C语言(宏替换之前)运行之前，(引导干的)你的.data段已经被赋值，.bss段被清0. 
全局变量：链接属性是外链接(文件级别)，而加了static修饰的全局变量就变成了本文件链接属性(内链接) 
* 函数：默认是外链接，static修饰的函数变成了内链接，只在本文件起作用。

