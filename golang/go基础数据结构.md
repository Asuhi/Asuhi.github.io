参考：https://draveness.me/golang/docs



##数组



```go
//初始化方式
arr1 := [3]int{1, 2, 3}
arr2 := [...]int{1, 2, 3}
```



arr1和arr2初始化时这两种方法完全等价，[...]的方式只是编译器提供的语法糖。

在编译阶段编译器会调用`typecheckcomplit`函数对数组大小进行推导。



###编译器对与数组的优化

1. 当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；
2. 当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；



当第一种情况时编译器会转换成：

```go
arr:=[3]int{1,2,3}
// 转换成 ↓
var arr [3]int
arr[0] = 1
arr[1] = 2
arr[2] = 3
```



但是如果当前数组的元素大于四个，会先获取一个唯一的 `staticname`然后在静态存储区初始化数组中的元素并将临时变量赋值给数组



```go
[5]int{1, 2, 3, 4, 5}
//伪代码如下 ↓
var arr [5]int
statictmp_0[0] = 1
statictmp_0[1] = 2
statictmp_0[2] = 3
statictmp_0[3] = 4
statictmp_0[4] = 5
arr = statictmp_0
```





###数组访问与赋值



Go 语言中可以在编译期间的静态类型检查判断数组越界。

1. 访问数组的索引是非整数时，报错 “non-integer array index %v”；
2. 访问数组的索引是负数时，报错 “invalid array index %v (index must be non-negative)"；
3. 访问数组的索引越界时，报错 “invalid array index %v (out of bounds for %d-element array)"；



但是如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，我们需要 Go 语言运行时阻止不合法的访问。

Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时触发程序的运行时错误并导致崩溃退出





##切片



```
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```



- `Data` 是指向数组的指针,指向一块连续的空间，这个连续空间存储所有元素。
- `Len` 是当前切片的长度
- `Cap` 是当前切片的容量，即 `Data` 数组的大小



当我们使用 `[]int{1, 2, 3}` 创建切片时编译器会自动转换成



```go
var vstat [3]int
vstat[0] = 1
vstat[1] = 2
vstat[2] = 3
var vauto *[3]int = new([3]int)
*vauto = vstat
slice := vauto[:]
```



1. 根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；
2. 将这些字面量元素存储到初始化的数组中；
3. 创建一个同样指向 `[3]int` 类型的数组指针；
4. 将静态存储区的数组 `vstat` 赋值给 `vauto` 指针所在的地址；
5. 通过 `[:]` 操作获取一个底层使用 `vauto` 的切片；



当使用make关键字创建切片时，则是在运行时完成的。

运行时会调用`func makeslice(et *_type, len, cap int) unsafe.Pointer` 创建切片

但该函数会在最后调用mallocgc ： `return mallocgc(mem, et, true)`  申请内存。





运行时的切片创建可能会发生的错误：


1. 内存空间的大小发生了溢出
2. 申请的内存大于最大可分配的内存
3. 传入的长度小于 0 或者长度大于容量



###访问元素



首先获取切片长度的cap()和len()会在SSA编译阶段被转化成OpSliceLen` 和 `OpSliceCap 在一些情况下也会优化成，直接替换长度和容量，不需要在运行时获取。



访问下标元素的 `OINDEX` 操作也会在中间代码生成期间转换成对地址的直接访问。



切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，编译期间也会将包含 `range` 关键字的遍历转换成形式更简单的循环。



###扩容



1. 我们会先解析切片结构体获取它的数组指针、大小和容量，如果在追加元素后切片的大小大于容量，那么就会调用`runtime.growslice`对切片进行扩容并将新的元素依次加入切片。
2. 当切片容量不足时会调用 [`runtime.growslice`](https://draveness.me/golang/tree/runtime.growslice) 函数为切片扩容，扩容是为切片分配新的内存空间并拷贝原切片中元素的过程
   1. 如果期望容量大于当前容量的两倍就会使用期望容量；
   2. 如果当前切片的长度小于 1024 就会将容量翻倍；
   3. 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；
3. 当数组字节大小为1、8、2的倍数时会对内存进行对齐。
4. 函数最终会返回一个新的切片，其中包含了新的数组指针、大小和容量，这个返回的三元组最终会覆盖原切片。















