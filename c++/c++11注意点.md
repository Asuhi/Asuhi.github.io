## 线程构造时传递引用类型的参数



下面代码所示  fctor 需要一个引用类型的参数 msg



```c++
class Fctor {
public:
	void operator()(std::string& msg) {
		std::cout << "from t1 " << msg << std::endl;
		msg = "123";
	}
};

int main()
{
	std::string str = "456";
	std::thread t(Fctor(), str);

	t.join();

	std::cout << str << std::endl;
}

```



这段代码有两种可能：

1. 编译器报错 因为 fctor 需要传递引用 所以  “std::invoke”: 未找到匹配的重载函数 
2. 编译成功 但 str的值没有被修改成123  输出456 和 456



解决问题： 使用std::ref包裹参数str  

```c++
int main()
{
	std::string str = "456";
	std::thread t(Fctor(), std::ref(str));
	t.join();

	std::cout << str << std::endl;
}

如果主线程不在使用 str 就不必要考虑线程间的资源竞争问题了
可以使用std::move 移动资源到子线程
```

```c++
int main()
{
	std::string str = "456";
	std::thread t(Fctor(), std::move(str));
	t.join();
}

```

## cpu 个数

```c++
std::thread::hardware_concurrency();
```



## RAII 解锁方式

```c++
std::mutex mu;
{
    std::lock_guard<std::mutex> guard(mu);
}

```

```c++
std::mutex mu;
{
    std::lock_guard<std::mutex> guard(mu);
}
```







